#pragma once

#include <cmath>   // abs
#include <cstdint> // int32_t, int64_t
#include <cstdio>  // printf
#include <cstdlib> // exit

// Ignore clang-tidy in this case, since these are CMake defines
// NOLINTBEGIN(modernize-macro-to-enum) justified

//==============================================================================
// CMake defines
//==============================================================================

// Enable/disable features
#cmakedefine01 UM2_ENABLE_ASSERTS
#cmakedefine01 UM2_ENABLE_FLOAT64
#cmakedefine01 UM2_ENABLE_INT64

// Use external dependencies
#cmakedefine01 UM2_USE_CLANG_TIDY
#cmakedefine01 UM2_USE_CUDA
#cmakedefine01 UM2_USE_GMSH
#cmakedefine01 UM2_USE_OPENMP
#cmakedefine01 UM2_USE_PNG
#cmakedefine01 UM2_USE_TBB

// Set compile-time filtering of log messages
#define MIN_LOG_LEVEL @UM2_MIN_LOG_LEVEL@

//==============================================================================
// Includes
//==============================================================================

#if UM2_USE_OPENMP
#  include <omp.h>
#endif

#if UM2_USE_CUDA
#  include <cuda_runtime.h>
#endif

//==============================================================================
// Attributes
//==============================================================================

// Optimization
#ifdef PURE
#  error "PURE already defined"
#endif
#ifdef CONST
#  error "CONST already defined"
#endif
#ifdef HOT
#  error "HOT already defined"
#endif
#define PURE  [[gnu::pure]]
#define CONST [[gnu::const]]
#define HOT   [[gnu::hot]]

// TODO(kcvaughn): Once C++23 is supported, we can use [[assume(expr)]] instead.
// https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1774r8.pdf
#ifdef ASSUME
#  error "ASSUME already defined"
#endif
#if defined(__clang__)
#  define ASSUME(expr) __builtin_assume(expr)
#elif defined(__GNUC__)
#  define ASSUME(expr)                                                                   \
    if (expr) {                                                                          \
    } else {                                                                             \
      __builtin_unreachable();                                                           \
    }
#elif defined(__CUDACC__)
#  define ASSUME(expr) __assume(expr)
#else
#  if !UM2_USE_CLANG_TIDY
#    error "Unable to determine compiler"
#  endif
#  define ASSUME(expr)
#endif

// CUDA
#ifdef HOST
#  error "HOST already defined"
#endif
#ifdef DEVICE
#  error "DEVICE already defined"
#endif
#ifdef HOSTDEV
#  error "HOSTDEV already defined"
#endif
#ifdef GLOBAL
#  error "GLOBAL already defined"
#endif
#if UM2_USE_CUDA
#  define HOST    __host__
#  define DEVICE  __device__
#  define HOSTDEV __host__ __device__
#  define GLOBAL  __global__
#else
#  define HOST
#  define DEVICE
#  define HOSTDEV
#  define GLOBAL
#endif

//==============================================================================
// Typedefs
//==============================================================================

// Floating point type in API.
#if UM2_ENABLE_FLOAT64
using Float = double; // Floating point type in API
#else
using Float = float; // Floating point type in API
#endif

// Integer type for indices and integers in API.
#if UM2_ENABLE_INT64
using Size = int64_t; // Index type
using Int = int64_t;  // Integer type in API
HOSTDEV consteval auto
sizeMax() -> Size
{
  return 0x7FFFFFFFFFFFFFFF;
}
#else
using Size = int32_t; // Index type
using Int = int32_t;  // Integer type in API
HOSTDEV consteval auto
sizeMax() -> Size
{
  return 0x7FFFFFFF;
}
#endif

// Integer type for material IDs.
using MaterialID = int8_t;

// For static_asserts which are always false.
template <class... T>
constexpr bool always_false = false;

//==============================================================================
// Assertions
//==============================================================================
//    
// ASSERT(expr) - Asserts that expr is true.    
//  If UM2_ENABLE_ASSERTS is 0, ASSERT does nothing and expr is not evaluated.    
//    
// ASSERT_NEAR(a, b, eps) - Asserts that a and b are within eps of each other.    
//  If UM2_ENABLE_ASSERTS is 0, ASSERT_NEAR does nothing and a, b, and eps are not    
//  evaluated.    
//
// ASSERT_ASSUME(expr) - Asserts that expr is true, with varying effects.
//  If UM2_ENABLE_ASSERTS is 1, this is equivalent to ASSERT(expr).
//  If UM2_ENABLE_ASSERTS is 0, this is equivalent to ASSUME(expr).

// Overlead abs() for host and device code.
namespace um2
{
#ifndef __CUDA_ARCH__
template <typename T>
CONST HOST constexpr auto
abs(T x) noexcept -> T
{
  return std::abs(x);
}
#else
template <std::integral T>
CONST DEVICE constexpr auto
abs(T x) noexcept -> T
{
  return ::abs(x);
}
CONST DEVICE constexpr auto
abs(float x) noexcept -> float
{
  return ::fabsf(x);
}
CONST DEVICE constexpr auto
abs(double x) noexcept -> double
{
  return ::fabs(x);
}
#endif
} // namespace um2

#if !UM2_ENABLE_ASSERTS
#  define ASSERT(expr)
#  define ASSERT_NEAR(a, b, eps)
#  define ASSERT_ASSUME(expr) ASSUME(expr)
#else
// If we are not using CUDA, assertions can be [[noreturn]].
namespace um2
{

# ifndef __CUDA_ARCH__
[[noreturn]] inline void
failedAssert(char const * const file, int const line, char const * const msg)
{
  printf("Assertion failed: %s:%d: %s\n", file, line, msg);
  exit(1);
}

[[noreturn]] inline void
failedAssertNear(char const * const file, int const line, char const * const a,
                 char const * const b, char const * const eps)
{
  printf("Assertion failed: %s:%d: Expected %s == %s +/- %s\n", file, line, a, b, eps);
  exit(1);
}
# else 
DEVICE inline void
failedAssert(char const * const file, int const line, char const * const msg)
{
  printf("Assertion failed: %s:%d: %s\n", file, line, msg);
  __threadfence();
  asm("trap;");
}

DEVICE inline void
failedAssertNear(char const * const file, int const line, char const * const a,
                 char const * const b, char const * const eps)
{
  printf("Assertion failed: %s:%d: Expected %s == %s +/- %s\n", file, line, a, b, eps);
  __threadfence();
  asm("trap;");
}
#  endif
} // namespace um2

#  define ASSERT(cond)                                                                   \
    if (!(cond)) {                                                                       \
      um2::failedAssert(__FILE__, __LINE__, #cond);                                      \
    }

#  define ASSERT_NEAR(a, b, eps)                                                         \
    {                                                                                    \
      auto const a_eval = (a);                                                           \
      auto const b_eval = (b);                                                           \
      auto const diff = um2::abs(a_eval - b_eval);                                       \
      if (diff > (eps)) {                                                                \
        um2::failedAssertNear(__FILE__, __LINE__, #a, #b, #eps);                         \
      }                                                                                  \
    }

#define ASSERT_ASSUME(expr) ASSERT(expr)

#endif // UM2_ENABLE_ASSERTS

//==============================================================================
// CUDA error checking
//==============================================================================

#if UM2_USE_CUDA && UM2_ENABLE_ASSERTS
#  define CUDA_CHECK_ERROR(status)                                                       \
    {                                                                                    \
      if (status != cudaSuccess) {                                                       \
        printf("CUDA error: %s:%d: %s\n", __FILE__, __LINE__, cudaGetErrorString(status)); \
        exit(1);                                                                         \
      }                                                                                  \
    }
#else
#  define CUDA_CHECK_ERROR(status)
#endif

// NOLINTEND(modernize-macro-to-enum)
