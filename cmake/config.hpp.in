#pragma once

//==============================================================================
// CMake defines
//==============================================================================

// Ignore clang-tidy, since these are CMake defines
// NOLINTBEGIN(modernize-macro-to-enum)

// Use external dependencies
#cmakedefine01 UM2_USE_CUDA
#cmakedefine01 UM2_USE_GMSH
#cmakedefine01 UM2_USE_OPENMP
#cmakedefine01 UM2_USE_TBB

// Enable/disable features
#cmakedefine01 UM2_ENABLE_ASSERTS
#cmakedefine01 UM2_ENABLE_FLOAT64
#cmakedefine01 UM2_ENABLE_INT64
#cmakedefine01 UM2_ENABLE_BMI2
#cmakedefine01 UM2_ENABLE_SIMD_VEC

// Minimum log level for compile-time filtering of log messages
#define MIN_LOG_LEVEL @UM2_MIN_LOG_LEVEL@

// Default path to look for MPACT cross section libraries
#define MPACT_DATA_DIR "@MPACT_DATA@"

// NOLINTEND(modernize-macro-to-enum)

//==============================================================================
// Includes
//==============================================================================

#include <cstdint> // int32_t, int64_t
//
//#if UM2_USE_OPENMP
//#  include <omp.h>
//#endif
//
//#if UM2_USE_CUDA
//#  include <cuda_runtime.h>
//#endif

//==============================================================================
// Attributes
//==============================================================================

// Optimization
#ifdef PURE
#  error "PURE already defined"
#endif
#ifdef CONST
#  error "CONST already defined"
#endif
#ifdef HOT
#  error "HOT already defined"
#endif
#define PURE  [[gnu::pure]]
#define CONST [[gnu::const]]
#define HOT   [[gnu::hot]]

// TODO(kcvaughn): Once C++23 is supported, we can use [[assume(expr)]] instead.
// https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1774r8.pdf
// https://github.com/KyleVaughn/UM2/issues/142
// For now, each compiler has its own assume implementation (GCC's being the worst).
#ifdef ASSUME
#  error "ASSUME already defined"
#endif
#if defined(__clang__)
#  define ASSUME(expr) __builtin_assume(expr)
#elif defined(__GNUC__)
#  define ASSUME(expr)                                                                   \
    if (expr) {                                                                          \
    } else {                                                                             \
      __builtin_unreachable();                                                           \
    }
#elif defined(__CUDACC__)
#  define ASSUME(expr) __assume(expr)
#else
#  define ASSUME(expr)
#endif

// CUDA
#ifdef HOST
#  error "HOST already defined"
#endif
#ifdef DEVICE
#  error "DEVICE already defined"
#endif
#ifdef HOSTDEV
#  error "HOSTDEV already defined"
#endif
#ifdef GLOBAL
#  error "GLOBAL already defined"
#endif
#if UM2_USE_CUDA
#  define HOST    __host__
#  define DEVICE  __device__
#  define HOSTDEV __host__ __device__
#  define GLOBAL  __global__
#else
#  define HOST
#  define DEVICE
#  define HOSTDEV
#  define GLOBAL
#endif

//==============================================================================
// Typedefs
//==============================================================================

// Floating point type
#if UM2_ENABLE_FLOAT64
using Float = double;
#else
using Float = float;
#endif

// Integer type
#if UM2_ENABLE_INT64
using Int = int64_t;
HOSTDEV consteval auto
intMax() noexcept -> Int
{
  return INT64_MAX;
}
#else
using Int = int32_t;
HOSTDEV consteval auto
intMax() noexcept -> Int
{
  return INT32_MAX;
}
#endif

// Integer type for material IDs.
// We don't expect more than 127 materials, so we use int8_t.
using MatID = int8_t;
HOSTDEV consteval auto
matIDMax() noexcept -> MatID
{
  return INT8_MAX;
}

//==============================================================================
// Functions
//==============================================================================

// For static_asserts which are always false.
template <class... T>
constexpr bool always_false = false;

//////==============================================================================
////// CUDA error checking
//////==============================================================================
////
/*
/////#if UM2_USE_CUDA && UM2_ENABLE_ASSERTS
/////#  define CUDA_CHECK_ERROR(status)                                                       \
/////    {                                                                                    \
/////      if (status != cudaSuccess) {                                                       \
/////        printf("CUDA error: %s:%d: %s\n", __FILE__, __LINE__, cudaGetErrorString(status)); \
/////        exit(1);                                                                         \
/////      }                                                                                  \
/////    }
/////#else
/////#  define CUDA_CHECK_ERROR(status)
/////#endif
*/
