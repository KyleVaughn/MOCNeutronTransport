import Base: intersect

struct Triangle6{T <: AbstractFloat} <: Face
    points::NTuple{6, Point{T}}
end

# Constructors
# -------------------------------------------------------------------------------------------------
Triangle6(p₁::Point{T}, 
         p₂::Point{T}, 
         p₃::Point{T},
         p₄::Point{T},
         p₅::Point{T},
         p₆::Point{T}
        ) where {T <: AbstractFloat} = Triangle6((p₁, p₂, p₃, p₄, p₅, p₆))


# Methods
# -------------------------------------------------------------------------------------------------
function (tri6::Triangle6)(r::T, s::T) where {T <: AbstractFloat}
    weights = [(1 - r - s)*(2(1 - r - s) - 1), 
                                     r*(2r-1),
                                     s*(2s-1),
                               4r*(1 - r - s),
                                         4r*s,
                               4s*(1 - r - s)]
    return sum(weights .* tri6.points) 
end

function derivatives(tri6::Triangle6{T}, r::T, s::T) where {T <: AbstractFloat}
    # Return ( dtri6/dr(r, s), dtri6/ds(r, s) )
    d_dr = (4r + 4s - 3)*tri6.points[1] + 
                (4r - 1)*tri6.points[2] +
           4(1 - 2r - s)*tri6.points[4] +     
                    (4s)*tri6.points[5] +
                   (-4s)*tri6.points[6]

    d_ds = (4r + 4s - 3)*tri6.points[1] + 
                (4s - 1)*tri6.points[3] +
                   (-4r)*tri6.points[4] +
                    (4r)*tri6.points[5] +
           4(1 - r - 2s)*tri6.points[6]     
    return (d_dr, d_ds) 
end

function gauss_legendre_quadrature(tri6::Triangle6{T}, N::Int64) where {T <: AbstractFloat}
    # The weights and points for Gauss-Legendre quadrature on the parametric unit triangle
    # ∑wᵢ= 1/2, rᵢ∈ [0, 1], sᵢ∈ [0, 1], rᵢ + sᵢ ≤ 1
    if N == 12
        w = [0.058393137863189,
             0.058393137863189,
             0.058393137863189,
             0.025422453185104,
             0.025422453185104,
             0.025422453185104,
             0.041425537809187,
             0.041425537809187,
             0.041425537809187,
             0.041425537809187,
             0.041425537809187,
             0.041425537809187]

        rs = [(0.249286745170910, 0.249286745170910), 
              (0.249286745170910, 0.501426509658179), 
              (0.501426509658179, 0.249286745170910),
              (0.063089014491502, 0.063089014491502),
              (0.063089014491502, 0.873821971016996),
              (0.873821971016996, 0.063089014491502),
              (0.310352451033785, 0.636502499121399),
              (0.636502499121399, 0.053145049844816),
              (0.053145049844816, 0.310352451033785),
              (0.310352451033785, 0.053145049844816),
              (0.636502499121399, 0.310352451033785),
              (0.053145049844816, 0.636502499121399)]

    elseif N == 27
        w = [0.00046350316448,
             0.00046350316448,
             0.00046350316448,
             0.03857476745740,
             0.03857476745740,
             0.03857476745740,
             0.02966148869040,
             0.02966148869040,
             0.02966148869040,
             0.01809227025170,
             0.01809227025170,
             0.01809227025170,
             0.00682986550135,
             0.00682986550135,
             0.00682986550135,
             0.02616855598110,
             0.02616855598110,
             0.02616855598110,
             0.02616855598110,
             0.02616855598110,
             0.02616855598110,
             0.01035382981955,
             0.01035382981955,
             0.01035382981955,
             0.01035382981955,
             0.01035382981955,
             0.01035382981955]

        rs = [(+0.5346110482710, +0.5346110482710),
              (-0.0692220965415, +0.5346110482710),
              (+0.5346110482710, -0.0692220965415),
              (+0.3989693029660, +0.3989693029660),
              (+0.2020613940680, +0.3989693029660),
              (+0.3989693029660, +0.2020613940680),
              (+0.2033099004310, +0.2033099004310),
              (+0.5933801991370, +0.2033099004310),
              (+0.2033099004310, +0.5933801991370),
              (+0.1193509122830, +0.1193509122830),
              (+0.7612981754350, +0.1193509122830),
              (+0.1193509122830, +0.7612981754350),
              (+0.0323649481113, +0.0323649481113),
              (+0.9352701037770, +0.0323649481113),
              (+0.0323649481113, +0.9352701037770),
              (+0.5932012134280, +0.3566206482610),
              (+0.0501781383105, +0.5932012134280),
              (+0.3566206482610, +0.0501781383105),
              (+0.0501781383105, +0.3566206482610),
              (+0.3566206482610, +0.5932012134280),
              (+0.5932012134280, +0.0501781383105),
              (+0.8074890031600, +0.1714889803040),
              (+0.0210220165362, +0.8074890031600),
              (+0.1714889803040, +0.0210220165362),
              (+0.0210220165362, +0.1714889803040),
              (+0.1714889803040, +0.8074890031600),
              (+0.8074890031600, +0.0210220165362)]
    else
        w = T[]
        rs = Tuple{T, T}[]
    end
    return w, rs
end

function area(tri6::Triangle6{T}; N::Int64=12) where {T <: AbstractFloat}
    # Numerical integration required. Gauss-Legendre quadrature over a triangle is used.
    # Let T(r,s) be the interpolation function for tri6,
    #                             1 1-r                          N
    # A = ∬ ||∂T/∂r × ∂T/∂s||dA = ∫  ∫ ||∂T/∂r × ∂T/∂s|| ds dr = ∑ wᵢ||∂T/∂r(rᵢ,sᵢ) × ∂T/∂s(rᵢ,sᵢ)||
    #      D                      0  0                          i=1
    #
    # NOTE: for 2D, N = 12 appears to be sufficient. For 3D, N = 27 is better, but a higher number
    # of points may be necessary.
    w, rs = gauss_legendre_quadrature(tri6, N)
    return sum(w .* norm.([dr × ds for (dr, ds) in [derivatives(tri6, r, s) for (r, s) in rs]]))
end
# area, integrate or trianglulate.

# triangulate.
#function intersect(l::LineSegment, tri::Triangle)
#end
