# Dunavant, D. (1985). High degree efficient symmetrical Gaussian quadrature rules
# for the triangle. International journal for numerical methods in engineering, 21(6),
# 1129-1148.
using LinearAlgebra
using Optim
using StaticArrays
using BenchmarkTools

setprecision(BigFloat, 256)
eps_128 = 1e-78
const T = Float64

# Polynomial degree
#const p = parse(Int64, ARGS[1])
const p = 2

# m values from Table I.
const m_all = SVector(1, 2, 3, 4, 5, 7, 8, 10, 12, 14, 16, 19, 21, 24, 27, 30, 33, 37, 40, 44)
const m = m_all[p]

# Polar moments from Table I.
const ν_all = SVector( 
        +1//1,
        +1//4,
        -1//10,
        +1//10,
        -2//35,
       +29//560,
        +1//28,
        -1//28,
       +11//350,
        +1//40,
       -37//1540,
        -1//55,
       +13//616,
        +1//55,
       -49//2860,
        -2//143,
      +425//28028,
      +137//10010,
        +1//91,
       -64//5005,
        -1//91,
      +523//45760,
       +85//8008,
        +1//112,
     -6733//680680,
      -109//12376,
        -1//136,
      +217//24310,
      +209//24752,
        +1//136,
     -2909//369512,
       -65//9044,
        -2//323,
    +66197//9237800,
     +8069//1175720,
      +317//51680,
        +1//190,
     -3769//587860,
       -77//12920,
        -1//190,
    +83651//14226212,
    +11303//1989680,
       +92//17765,
        +1//220)
const ν = SVector{m, T}(ν_all[1:m])

# Polar moment indices from Table I.
const iν_all = SMatrix{44, 2, Int64, 88}(
    0, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 20, 
    0, 0, 3, 0, 3, 0, 6, 3, 0, 6, 3, 9,  0,  6,  3,  9,  0,  6, 12,  3,  9,  0,  6, 12,  3,  9, 15,  0,  6, 12,  3,  9, 15,  0,  6, 12, 18,  3,  9, 15,  0,  6, 12, 18
   )
const iν = SMatrix{m, 2, Int64, 2m}(iν_all[1:m, :])

# n₀, n₁, n₂ values provided in Table IV, 
# the number of groups of multiplicity 1, 3, and 6
const nᵢ= SVector((1, 0, 0),
                  (0, 1, 0),
                  (1, 1, 0),
                  (0, 2, 0),
                  (1, 2, 0),
                  (0, 2, 1),
                  (1, 2, 1),
                  (1, 3, 1),
                  (1, 4, 1),
                  (1, 2, 3),
                  (0, 5, 2),
                  (0, 5, 3),
                  (1, 6, 3),
                  (0, 6, 4),
                  (0, 6, 5),
                  (1, 7, 5),
                  (1, 8, 6),
                  (1, 9, 7),
                  (1, 8, 8),
                  (1, 10, 8))
const n₀, n₁, n₂ = nᵢ[p]
# calculate the number of unknowns
const n = n₀ + 2n₁ + 3n₂
# calculate the number of gaussian points and weights
const ng = n₀ + 3n₁ + 6n₂

# The error in equation 22b for moment iM given 
# x = {w₀ if n₀ = 1} ∪ {wᵢ, rᵢ for i = 1:n₁} ∪ {wᵢ, rᵢ, 3αᵢ for i = n₁+1:n₂}
function moment_error(x::MVector{n, T}, iM::Int64)
    err = -ν[iM]
    j = iν[iM, 1]
    k = iν[iM, 2]
    if n₀ === 1 && iM === 1
        err += x[1]
    end
    for i = n₀+1 : 2 : n₀ + 2n₁
        err += x[i]*x[i+1]^j
    end
    for i = n₀ + 2n₁ + 1: 3 : n
        err += x[i]*x[i+1]^j * cos(k*x[i+2])
    end
    return err 
end

# The sum or the squared error in each unknown 
function objective(x::MVector{n, T})
    sum_err = zero(T)
    for iM = 1:m
        sum_err += moment_error(x, iM)^2
    end
    return sum_err
end

# Guess weights as in equations 39a-c
initial_guess = @MVector zeros(T, n)

    if n₀ === 1 && iM === 1
        err += x[1]
    end
    for i = n₀+1 : 2 : n₀ + 2n₁
        err += x[i]*x[i+1]^j
    end
    for i = n₀ + 2n₁ + 1: 3 : n
        err += x[i]*x[i+1]^j * cos(k*x[i+2])
    end



@time res = optimize(objective, ones(T, m+3)/10, SimulatedAnnealing(), 
                         Optim.Options(f_tol=eps(T), 
                                       iterations=Int64(1e7),
                                       time_limit = 10))

















##
##function area!(x,w,alpha,beta,gamma,n0,n1,n2,ilb,ile,i2b,i2e,inu,dnu,T)
##    icount=1
##    if !(n0 == 0)
##        w[icount] = x[1]
##        alpha[icount] = T(1//3)
##        beta[icount] = (1 - alpha[icount])/2
##        gamma[icount] = beta[icount]
##        icount = icount + 1
##    end
##    if !(n1 == 0)
##        for i = ilb:2:ile
##            w[icount] = x[i]/3
##            alpha[icount] = (1 - 2x[i+1])/3
##            beta[icount] = (1 - alpha[icount])/2
##            gamma[icount] = beta[icount]
##            icount = icount + 1
##        end
##    end
##    if !(n2 == 0)
##        for i = i2b:3:i2e
##            w[icount]=x[i]/6
##            r=x[i+1]
##            a=x[i+2]
##            alpha[icount] = (1 - 2*r*cos(a))/3
##            beta[icount] = (1 + r*cos(a) - sqrt(T(3))*r*sin(a))/3
##            gamma[icount] = 1 - alpha[icount] - beta[icount]
##            icount = icount + 1
##        end
##    end
##end
##
#initial_guesses = []
#function get_weights(p)
#    # dimension
#    w     = @MVector zeros(T, 19)
#    alpha = @MVector zeros(T, 19)
#    beta  = @MVector zeros(T, 19)
#    gamma = @MVector zeros(T, 19)
#    # calculate the order of the polynomial
#    n0, n1, n2 = nvalues(ip)
#    # calculate the sum of the number of groups
#    nsum = n0 + n1 + n2
#    # calculate the pointers for n1 and n2
#    ilb = n0 + 1
#    ile = ilb + 2*n1 - 1
#    i2b = ile + 1
#    i2e = i2b + 3*n2 - 1


#    # calculate the number of unknowns
#    n = n0 + 2*n1 + 3*n2
#    # calculate the number of equations
#    ipcopy = mod(ip, 6)
#    ialpha = 0
#    inu, dnu = nu(p) 
#    function f(x) 
#        y = @MVector zeros(T, m)
#        for iM = 1:m
#            y[iM] = -dnu[iM]
#            if iM == 1 && n0 == 1
#                y[1] = y[1] + x[1]
#            end
#            if n1 != 0 # 10
#                for i = ilb:2:ile
#                    y[iM] = y[iM] + x[i]*x[i+1]^inu[iM,1]
#                end
#            end
#            if n2 != 0
#                for i = i2b:3:i2e
#                    dk3 = T(inu[iM,2])
#                    y[iM] = y[iM] + x[i]*x[i+1]^inu[iM,1] * cos(dk3*x[i+2])
#                end
#            end
#        end
#        return y
#    end
#    return f(ones(T, m+3))
##    @time res = optimize(f, ones(T, m+3)/10, SimulatedAnnealing(), 
##                         Optim.Options(f_tol=eps(T), 
##                                       iterations=Int64(1e7),
##                                       time_limit = 10))
##    x = Optim.minimizer(res)
##    push!(initial_guesses, x)
##    println("Polynomial of degree ", p)
##    println(res)
#end
###solutions = []
###coords = []
###for p ∈ 1:10
###    # dimension
###    w     = zeros(BigFloat, 19)
###    alpha = zeros(BigFloat, 19)
###    beta  = zeros(BigFloat, 19)
###    gamma = zeros(BigFloat, 19)
###    # common
###    inu   = zeros(Int64, 44, 2)
###    dnu   = zeros(Rational, 44)
###    # calculate the order of the polynomial
###    ip = p
###    # calculate the number of groups of multiplicity 1,3, and 6
###    n0, n1, n2 = nvalues(ip)
###    # calculate the sum of the number of groups
###    nsum = n0 + n1 + n2
###    # calculate the pointers for n1 and n2
###    ilb = n0 + 1
###    ile = ilb + 2*n1 - 1
###    i2b = ile + 1
###    i2e = i2b + 3*n2 - 1
###    # calculate the number of gaussian points and weights
###    ng = n0 + 3*n1 + 6*n2
###    # calculate the number of unknowns
###    n = n0 + 2*n1 + 3*n2
###    # calculate the number of equations
###    ipcopy = mod(ip, 6)
###    ialpha = 0
###    if ipcopy == 0
###        ialpha = 3
###    end
###    if ipcopy == 1 || ipcopy == 5
###        ialpha = -4
###    end
###    if ipcopy == 2 || ipcopy == 4
###        ialpha = -1
###    end
###    if ipcopy == 3
###        ialpha = 0
###    end
###    # m in Table I
###    m = ((ip + 3)^2 + ialpha) ÷ 12
###    nu!(ip, inu, dnu)
###    f(x) = norm(func(x,m,n,n0,n1,n2,ilb,ile,i2b,i2e,inu,dnu,BigFloat))
###    @time res = optimize(f, BigFloat.(initial_guesses[ip]), 
###                         Optim.Options(g_tol=eps_128, iterations=1000000))
###    x = Optim.minimizer(res)
###    push!(initial_guesses, x)
###    area!(x,w,alpha,beta,gamma,n0,n1,n2,ilb,ile,i2b,i2e,inu,dnu,BigFloat)
###    push!(coords, (w,alpha,beta,gamma))
###
###    println("Polynomial of degree ", p)
###    println("Number of Gaussian points: ", ng)
####    println(x)
###    println(res)
####    for i = 1:nsum
####        println("   ",w[i]," ",alpha[i]," ",beta[i]," ",gamma[i])
####    end
###end
###
###
###
###
###
###
###
###
###
###weights20 = T[+0.016528527770800,
###          +0.000433509592831,
###          +0.000433509592831,
###          +0.000433509592831,
###          +0.005830026358200,
###          +0.005830026358200,
###          +0.005830026358200,
###          +0.011438468178200,
###          +0.011438468178200,
###          +0.011438468178200,
###          +0.015224491336950,
###          +0.015224491336950,
###          +0.015224491336950,
###          +0.015312445862700,
###          +0.015312445862700,
###          +0.015312445862700,
###          +0.012184028838400,
###          +0.012184028838400,
###          +0.012184028838400,
###          +0.007998716016000,
###          +0.007998716016000,
###          +0.007998716016000,
###          +0.003849150907800,
###          +0.003849150907800,
###          +0.003849150907800,
###          -0.000316030248744,
###          -0.000316030248744,
###          -0.000316030248744,
###          +0.000875567150595,
###          +0.000875567150595,
###          +0.000875567150595,
###          +0.008232919594800,
###          +0.008232919594800,
###          +0.008232919594800,
###          +0.008232919594800,
###          +0.008232919594800,
###          +0.008232919594800,
###          +0.002419516770245,
###          +0.002419516770245,
###          +0.002419516770245,
###          +0.002419516770245,
###          +0.002419516770245,
###          +0.002419516770245,
###          +0.012902453267350,
###          +0.012902453267350,
###          +0.012902453267350,
###          +0.012902453267350,
###          +0.012902453267350,
###          +0.012902453267350,
###          +0.004235545527220,
###          +0.004235545527220,
###          +0.004235545527220,
###          +0.004235545527220,
###          +0.004235545527220,
###          +0.004235545527220,
###          +0.009177457053150,
###          +0.009177457053150,
###          +0.009177457053150,
###          +0.009177457053150,
###          +0.009177457053150,
###          +0.009177457053150,
###          +0.000352202338954,
###          +0.000352202338954,
###          +0.000352202338954,
###          +0.000352202338954,
###          +0.000352202338954,
###          +0.000352202338954,
###          +0.005056342463750,
###          +0.005056342463750,
###          +0.005056342463750,
###          +0.005056342463750,
###          +0.005056342463750,
###          +0.005056342463750,
###          +0.001786954692975,
###          +0.001786954692975,
###          +0.001786954692975,
###          +0.001786954692975,
###          +0.001786954692975,
###          +0.001786954692975]
###
###r20 = T[+0.3333333333333,
###          +0.5009504643520,
###          -0.0019009287044,
###          +0.5009504643520,
###          +0.4882129579350,
###          +0.0235740841305,
###          +0.4882129579350,
###          +0.4551366869500,
###          +0.0897266360994,
###          +0.4551366869500,
###          +0.4019962593180,
###          +0.1960074813630,
###          +0.4019962593180,
###          +0.2558929097590,
###          +0.4882141804810,
###          +0.2558929097590,
###          +0.1764882559950,
###          +0.6470234880100,
###          +0.1764882559950,
###          +0.1041708553370,
###          +0.7916582893260,
###          +0.1041708553370,
###          +0.0530689638409,
###          +0.8938620723180,
###          +0.0530689638409,
###          +0.0416187151960,
###          +0.9167625696080,
###          +0.0416187151960,
###          +0.0115819214068,
###          +0.9768361571860,
###          +0.0115819214068,
###          +0.6064026461060,
###          +0.0487415836648,
###          +0.3448557702290,
###          +0.0487415836648,
###          +0.3448557702290,
###          +0.6064026461060,
###          +0.6158426144570,
###          +0.0063141159486,
###          +0.3778432695950,
###          +0.0063141159486,
###          +0.3778432695950,
###          +0.6158426144570,
###          +0.5590480003900,
###          +0.1343165205470,
###          +0.3066354790620,
###          +0.1343165205470,
###          +0.3066354790620,
###          +0.5590480003900,
###          +0.7366067432630,
###          +0.0139738939624,
###          +0.2494193627750,
###          +0.0139738939624,
###          +0.2494193627750,
###          +0.7366067432630,
###          +0.7116751422870,
###          +0.0755491329098,
###          +0.2127757248030,
###          +0.0755491329098,
###          +0.2127757248030,
###          +0.7116751422870,
###          +0.8614027171550,
###          -0.0083681532082,
###          +0.1469654360530,
###          -0.0083681532082,
###          +0.1469654360530,
###          +0.8614027171550,
###          +0.8355869579120,
###          +0.0266860632587,
###          +0.1377269788290,
###          +0.0266860632587,
###          +0.1377269788290,
###          +0.8355869579120,
###          +0.9297561715570,
###          +0.0105477192941,
###          +0.0596961091490,
###          +0.0105477192941,
###          +0.0596961091490,
###          +0.9297561715570]
###
###    s20 = T[ +0.3333333333333,
###           +0.5009504643520,
###           +0.5009504643520,
###           -0.0019009287044,
###           +0.4882129579350,
###           +0.4882129579350,
###           +0.0235740841305,
###           +0.4551366869500,
###           +0.4551366869500,
###           +0.0897266360994,
###           +0.4019962593180,
###           +0.4019962593180,
###           +0.1960074813630,
###           +0.2558929097590,
###           +0.2558929097590,
###           +0.4882141804810,
###           +0.1764882559950,
###           +0.1764882559950,
###           +0.6470234880100,
###           +0.1041708553370,
###           +0.1041708553370,
###           +0.7916582893260,
###           +0.0530689638409,
###           +0.0530689638409,
###           +0.8938620723180,
###           +0.0416187151960,
###           +0.0416187151960,
###           +0.9167625696080,
###           +0.0115819214068,
###           +0.0115819214068,
###           +0.9768361571860,
###           +0.3448557702290,
###           +0.6064026461060,
###           +0.0487415836648,
###           +0.3448557702290,
###           +0.6064026461060,
###           +0.0487415836648,
###           +0.3778432695950,
###           +0.6158426144570,
###           +0.0063141159486,
###           +0.3778432695950,
###           +0.6158426144570,
###           +0.0063141159486,
###           +0.3066354790620,
###           +0.5590480003900,
###           +0.1343165205470,
###           +0.3066354790620,
###           +0.5590480003900,
###           +0.1343165205470,
###           +0.2494193627750,
###           +0.7366067432630,
###           +0.0139738939624,
###           +0.2494193627750,
###           +0.7366067432630,
###           +0.0139738939624,
###           +0.2127757248030,
###           +0.7116751422870,
###           +0.0755491329098,
###           +0.2127757248030,
###           +0.7116751422870,
###           +0.0755491329098,
###           +0.1469654360530,
###           +0.8614027171550,
###           -0.0083681532082,
###           +0.1469654360530,
###           +0.8614027171550,
###           -0.0083681532082,
###           +0.1377269788290,
###           +0.8355869579120,
###           +0.0266860632587,
###           +0.1377269788290,
###           +0.8355869579120,
###           +0.0266860632587,
###           +0.0596961091490,
###           +0.9297561715570,
###           +0.0105477192941,
###           +0.0596961091490,
###           +0.9297561715570,
###           +0.0105477192941]
