# Dunavant, D. (1985). High degree efficient symmetrical Gaussian quadrature rules
# for the triangle. International journal for numerical methods in engineering, 21(6),
# 1129-1148.
using LinearAlgebra
using Optim
using StaticArrays
using BenchmarkTools

setprecision(BigFloat, 512)
const T = BigFloat 

# Polynomial degree
const p = parse(Int64, ARGS[1])

# m values from Table I.
const m_all = SVector(1, 2, 3, 4, 5, 7, 8, 10, 12, 14, 16, 19, 21, 24, 27, 30, 33, 37, 40, 44)
const m = m_all[p]

# Polar moments from Table I.
const ν_all = SVector( 
        +1//1,
        +1//4,
        -1//10,
        +1//10,
        -2//35,
       +29//560,
        +1//28,
        -1//28,
       +11//350,
        +1//40,
       -37//1540,
        -1//55,
       +13//616,
        +1//55,
       -49//2860,
        -2//143,
      +425//28028,
      +137//10010,
        +1//91,
       -64//5005,
        -1//91,
      +523//45760,
       +85//8008,
        +1//112,
     -6733//680680,
      -109//12376,
        -1//136,
      +217//24310,
      +209//24752,
        +1//136,
     -2909//369512,
       -65//9044,
        -2//323,
    +66197//9237800,
     +8069//1175720,
      +317//51680,
        +1//190,
     -3769//587860,
       -77//12920,
        -1//190,
    +83651//14226212,
    +11303//1989680,
       +92//17765,
        +1//220)
const ν = SVector{m, T}(ν_all[1:m])

# Polar moment indices from Table I.
const iν_all = SMatrix{44, 2, Int64, 88}(
    0, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 20, 
    0, 0, 3, 0, 3, 0, 6, 3, 0, 6, 3, 9,  0,  6,  3,  9,  0,  6, 12,  3,  9,  0,  6, 12,  3,  9, 15,  0,  6, 12,  3,  9, 15,  0,  6, 12, 18,  3,  9, 15,  0,  6, 12, 18
   )
const iν = SMatrix{m, 2, Int64, 2m}(iν_all[1:m, :])

# n₀, n₁, n₂ values provided in Table IV, 
# the number of groups of multiplicity 1, 3, and 6
const nᵢ= SVector((1, 0, 0),
                  (0, 1, 0),
                  (1, 1, 0),
                  (0, 2, 0),
                  (1, 2, 0),
                  (0, 2, 1),
                  (1, 2, 1),
                  (1, 3, 1),
                  (1, 4, 1),
                  (1, 2, 3),
                  (0, 5, 2),
                  (0, 5, 3),
                  (1, 6, 3),
                  (0, 6, 4),
                  (0, 6, 5),
                  (1, 7, 5),
                  (1, 8, 6),
                  (1, 9, 7),
                  (1, 8, 8),
                  (1, 10, 8))
const n₀, n₁, n₂ = nᵢ[p]
# calculate the number of unknowns
const n = n₀ + 2n₁ + 3n₂
# calculate the number of gaussian points and weights
const ng = n₀ + 3n₁ + 6n₂

# Given α, β, and weights in Appendix II
if p === 1
    const αβw_Float64 = @SVector [
      (0.333333333333333, 0.333333333333333, 0.500000000000000)]
elseif p === 2
    const αβw_Float64 = @SVector [
      (0.666666666666667, 0.166666666666667, 0.166666666666667)]
elseif p === 3
    const αβw_Float64 = @SVector [
      (0.333333333333333, 0.333333333333333, -0.281250000000000),
      (0.600000000000000, 0.200000000000000, 0.260416666666667)]
elseif p === 4
    const αβw_Float64 = @SVector [
      (0.108103018168070, 0.445948490915965, 0.111690794839005),
      (0.816847572980459, 0.091576213509771, 0.054975871827661)]
elseif p === 5
    const αβw_Float64 = @SVector [
      (0.333333333333333, 0.333333333333333, 0.112500000000000),
      (0.059715871789770, 0.470142064105115, 0.066197076394253),
      (0.797426985353087, 0.101286507323456, 0.062969590272414)]
elseif p === 6
    const αβw_Float64 = @SVector [
      (0.501426509658179, 0.249286745170910, 0.058393137863189),
      (0.873821971016996, 0.063089014491502, 0.025422453185104),
      (0.053145049844816, 0.636502499121399, 0.041425537809187)]
elseif p === 7
    const αβw_Float64 = @SVector [
      (0.333333333333333, 0.333333333333333, -0.074785022233841),
      (0.479308067841920, 0.260345966079040, 0.087807628716604),
      (0.869739794195568, 0.065130102902216, 0.026673617804419),
      (0.048690315425316, 0.312865496004874, 0.038556880445128)]
elseif p === 8
    const αβw_Float64 = @SVector [
      (0.333333333333333, 0.333333333333333, 0.072157803838894),
      (0.081414823414554, 0.459292588292723, 0.047545817133643),
      (0.658861384496480, 0.170569307751760, 0.051608685267359),
      (0.898905543365938, 0.050547228317031, 0.016229248811599),
      (0.008394777409958, 0.263112829634638, 0.013615157087217)]
elseif p === 9
    const αβw_Float64 = @SVector [
      (0.3333333333330, 0.3333333333333, 0.04856789814140),
      (0.0206349616025, 0.4896825191990, 0.01566735011355),
      (0.1258208170140, 0.4370895914930, 0.03891377050240),
      (0.6235929287620, 0.1882035356190, 0.03982386946360),
      (0.9105409732110, 0.0447295133945, 0.01278883782935),
      (0.0368384120547, 0.2219629891613, 0.02164176968865)]
elseif p === 10
    const αβw_Float64 = @SVector [
      (0.3333333333330, 0.3333333333330, 0.04540899519140),
      (0.0288447332327, 0.4855776333840, 0.01836297887825),
      (0.7810368490300, 0.1094815754850, 0.02266052971775),
      (0.1417072194150, 0.5503529418210, 0.03637895842270),
      (0.0250035347627, 0.7283239045970, 0.01416362126555),
      (0.0095408154003, 0.9236559335870, 0.00471083348185)]
elseif p === 11
    const αβw_Float64 = @SVector [
      (-0.0692220965415, +0.5346110482710, 0.00046350316448),
      (+0.2020613940680, +0.3989693029660, 0.03857476745740),
      (+0.5933801991370, +0.2033099004310, 0.02966148869040),
      (+0.7612981754350, +0.1193509122830, 0.01809227025170),
      (+0.9352701037770, +0.0323649481113, 0.00682986550135),
      (+0.0501781383105, +0.3566206482610, 0.02616855598110),
      (+0.0210220165362, +0.1714889803040, 0.01035382981955)]
elseif p === 12
    const αβw_Float64 = @SVector [
      (0.0235652204524, 0.4882173897740, 0.01286553322025),
      (0.1205512154110, 0.4397243922940, 0.02184627226900),
      (0.4575792299760, 0.2712103850120, 0.03142911210895),
      (0.7448477089170, 0.1275761455420, 0.01739805646535),
      (0.9573652990940, 0.0213173504532, 0.00308313052578),
      (0.1153434945350, 0.2757132696860, 0.02018577888320),
      (0.0228383322223, 0.6958360867880, 0.01117838660115),
      (0.0257340505483, 0.1162519159080, 0.00865811555435)]
elseif p === 13
    const αβw_Float64 = @SVector [
      (0.33333333333330, 0.33333333333330, 0.026260461700400),
      (0.00990363012059, 0.49504818494000, 0.005640072604650),
      (0.06256672978090, 0.46871663511000, 0.015711759181250),
      (0.17095732639700, 0.41452133680100, 0.023536251252100),
      (0.54120085591400, 0.22939957204300, 0.023681793268200),
      (0.77115100960700, 0.11442449519600, 0.015583764522900),
      (0.95037721727300, 0.02481139136350, 0.003987885732535),
      (0.09485382837960, 0.26879499705900, 0.018424201364350),
      (0.01810077327880, 0.29173006673400, 0.008700731651900),
      (0.02223307667410, 0.12635738549200, 0.007760893419500)]
elseif p === 14
    const αβw_Float64 = @SVector [
      (0.02207217927560, 0.48896391036200, 0.01094179068470),
      (0.16471056131900, 0.41764471934000, 0.01639417677205),
      (0.45304494338200, 0.27347752830900, 0.02588705225365),
      (0.64558893517500, 0.17720553241300, 0.02108129436850),
      (0.87640023381800, 0.06179988309090, 0.00721684983490),
      (0.96121807750300, 0.01939096124870, 0.00246170180120),
      (0.05712475740360, 0.17226668782100, 0.01233287660630),
      (0.09291624935700, 0.33686145979600, 0.01928575539355),
      (0.01464695005570, 0.29837288213600, 0.00721815405675),
      (0.00126833093287, 0.11897449769700, 0.00250511441925)]
elseif p === 15
    const αβw_Float64 = @SVector [
      (-0.0139458337165, +0.5069729168580, 0.000958437821425),
      (+0.1371872914340, +0.4314063542830, 0.022124513635550),
      (+0.4446127103060, +0.2776936448470, 0.025593274359450),
      (+0.7470702179170, +0.1264648910410, 0.011843867935350),
      (+0.8583832280510, +0.0708083859747, 0.006644887845000),
      (+0.9620696595180, +0.0189651702411, 0.002374458304095),
      (+0.1337341619670, +0.2613113711400, 0.019275036299800),
      (+0.0363666773969, +0.3880467670900, 0.013607907160300),
      (-0.0101748831266, +0.2857122200500, 0.001091038683400),
      (+0.0368438698759, +0.2155996640720, 0.010752659923850),
      (+0.0124598093312, +0.1035756165760, 0.003836971315525)]
elseif p === 16
    const αβw_Float64 = @SVector [
      (+0.33333333333330, +0.33333333333330, 0.023437848713800),
      (+0.00523891610312, +0.49738054194800, 0.003202939289290),
      (+0.17306112290100, +0.41346943854900, 0.020855148369700),
      (+0.05908280186600, +0.47045859906700, 0.013445742125050),
      (+0.51889250006100, +0.24055374997000, 0.021066261380800),
      (+0.70406841155500, +0.14796579422300, 0.015000133421400),
      (+0.84906962468500, +0.07546518765750, 0.007100049462500),
      (+0.96680719475400, +0.01659640262300, 0.001791231175635),
      (+0.10357569224500, +0.29655559658000, 0.016386573730300),
      (+0.02008341165540, +0.33772306340300, 0.007649153124200),
      (-0.00434100261414, +0.20474828164300, 0.001193122096420),
      (+0.04194178646800, +0.18935849213100, 0.009542396377950),
      (+0.01431732023070, +0.08528361568270, 0.003425027273270)]
elseif p === 17
    const αβw_Float64 = @SVector [
      (0.33333333333330, 0.33333333333330, 0.016718599645400),
      (0.00565891888645, 0.49717054055700, 0.002546707720255),
      (0.03564735475080, 0.48217632262500, 0.007335432263800),
      (0.09952006195840, 0.45023996902100, 0.012175439176850),
      (0.19946752124500, 0.40026623937700, 0.015553775434500),
      (0.49571746405800, 0.25214126797100, 0.015628555609300),
      (0.67590599068300, 0.16204700465800, 0.012407827169850),
      (0.84824823547900, 0.07587588226070, 0.007028036535300),
      (0.96869054606400, 0.01565472696780, 0.001597338086890),
      (0.01018692882690, 0.33431986736400, 0.004059827659495),
      (0.13544087167100, 0.29222153779700, 0.013402871141600),
      (0.05442392429060, 0.31957488542300, 0.009229996605400),
      (0.01286856083360, 0.19070422419200, 0.004238434267165),
      (0.06716578241350, 0.18048321164900, 0.009146398385000),
      (0.01466318222480, 0.08071131367960, 0.003332816002085)]
elseif p === 18
    const αβw_Float64 = @SVector [
      (+0.33333333333330, +0.33333333333330, +0.015404969968800),
      (+0.01331038273820, +0.49334480863100, +0.004536218339700),
      (+0.06157881151610, +0.46921059424200, +0.009380658469800),
      (+0.12743720822600, +0.43628139588700, +0.009720548992750),
      (+0.21030765865300, +0.39484617067300, +0.013876974305400),
      (+0.50041086239400, +0.24979456880300, +0.016128112675750),
      (+0.67713561251200, +0.16143219374400, +0.012537016308450),
      (+0.84680354502900, +0.07659822748540, +0.007635963985900),
      (+0.95149512129300, +0.02425243935350, +0.003396961011480),
      (+0.91370726556600, +0.04314636721700, -0.001111549364960),
      (+0.00843053620242, +0.35891149494100, +0.003165957038205),
      (+0.13118655173700, +0.29440247675200, +0.013628769024550),
      (+0.05020315156570, +0.32501780164200, +0.008838392824750),
      (+0.06632926381090, +0.18473755966600, +0.009189742319050),
      (+0.01199619456620, +0.21879680001300, +0.004052366404095),
      (+0.01485810059010, +0.10117959713600, +0.003817064535365),
      (-0.03522201528790, +0.02087475528260, +2.3093830397e-05)]
elseif p === 19
    const αβw_Float64 = @SVector [
      (0.33333333333330, 0.33333333333330, 0.016453165694450),
      (0.02078002585400, 0.48960998707300, 0.005165365945650),
      (0.09092621460420, 0.45453689269800, 0.011193623631500),
      (0.19716663870100, 0.40141668064900, 0.015133062934750),
      (0.48889669119400, 0.25555165440300, 0.015245483901100),
      (0.64584411569600, 0.17707794215200, 0.012079606370800),
      (0.77987789354400, 0.11006105322800, 0.008025401793400),
      (0.88894275149600, 0.05552862425180, 0.004042290130890),
      (0.97475627244600, 0.01262186377720, 0.001039681013740),
      (0.00361141784841, 0.39575478735700, 0.001942438452490),
      (0.13446675453100, 0.30792998388000, 0.012787080306000),
      (0.01444602577610, 0.26456694840700, 0.004440451786670),
      (0.04693357883820, 0.35853935220600, 0.008062273380850),
      (0.00286112035057, 0.15780740596900, 0.001245970908745),
      (0.22386142409800, 0.07505059697590, 0.009121420059500),
      (0.03464707481680, 0.14242160111300, 0.005129281868100),
      (0.01016111929630, 0.06549462808290, 0.001899964427650)]
elseif p === 20
    const αβw_Float64 = @SVector [
      (+0.3333333333333, +0.3333333333333, +0.016528527770800),
      (-0.0019009287044, +0.5009504643520, +0.000433509592831),
      (+0.0235740841305, +0.4882129579350, +0.005830026358200),
      (+0.0897266360994, +0.4551366869500, +0.011438468178200),
      (+0.1960074813630, +0.4019962593180, +0.015224491336950),
      (+0.4882141804810, +0.2558929097590, +0.015312445862700),
      (+0.6470234880100, +0.1764882559950, +0.012184028838400),
      (+0.7916582893260, +0.1041708553370, +0.007998716016000),
      (+0.8938620723180, +0.0530689638409, +0.003849150907800),
      (+0.9167625696080, +0.0416187151960, -0.000316030248744),
      (+0.9768361571860, +0.0115819214068, +0.000875567150595),
      (+0.0487415836648, +0.3448557702290, +0.008232919594800),
      (+0.0063141159486, +0.3778432695950, +0.002419516770245),
      (+0.1343165205470, +0.3066354790620, +0.012902453267350),
      (+0.0139738939624, +0.2494193627750, +0.004235545527220),
      (+0.0755491329098, +0.2127757248030, +0.009177457053150),
      (-0.0083681532082, +0.1469654360530, +0.000352202338954),
      (+0.0266860632587, +0.1377269788290, +0.005056342463750),
      (+0.0105477192941, +0.0596961091490, +0.001786954692975)]
else
    error("Unsupported polynomial order")
end

# Given α and β, find r and a in the area function.
# x = [r, a]
function αβ_to_ra_error(x, α, β)
    r = x[1]
    a = x[2]
    α_err = (1 - 2r*cos(a))/3 - α
    β_err = (1 + r*cos(a) - sqrt(T(3))*r*sin(a))/3 - β
    return α_err^2 + β_err^2
end

function αβw_to_initial_guess()
    initial_guess = SizedVector{n, T}(zeros(T, n))
    icount = 1
    if n₀ === 1
        α,β,w = αβw_Float64[1]
        initial_guess[1] = 2w
        icount += 1
    end
    for i = n₀ + 1 : 2 : n₀ + 2n₁
        α,β,w = αβw_Float64[icount]       
        initial_guess[i]   = 6w
        initial_guess[i+1] = (1 - 3α)/2
        icount += 1
    end
    for i = n₀ + 2n₁ + 1: 3 : n
        α,β,w = αβw_Float64[icount]
        initial_guess[i] = 12w
        res = optimize(x -> αβ_to_ra_error(x, α, β),
                       [0.0, 0.0],
                       Optim.Options(g_tol=1e-30,
                                     iterations=Int64(1e4),
                                    )
                      )
        if !Optim.converged(res)
            println("r, a from α, β")
            println(res)
        end
        x = Optim.minimizer(res)
        initial_guess[i+1] = x[1]
        initial_guess[i+2] = x[2]
        icount += 1
    end
    return initial_guess
end

# The error in equation 22b for moment iM given 
# x = {w₀ if n₀ = 1} ∪ {wᵢ, rᵢ for i = 1:n₁} ∪ {wᵢ, rᵢ, 3αᵢ for i = n₁+1:n₂}
function moment_error(x::SizedVector{n, T, Vector{T}}, iM::Int64)
    err = -ν[iM]
    j = iν[iM, 1]
    k = iν[iM, 2]
    if n₀ === 1 && iM === 1
        err += x[1]
    end
    for i = n₀ + 1 : 2 : n₀ + 2n₁
        err += x[i]*x[i+1]^j
    end
    for i = n₀ + 2n₁ + 1: 3 : n
        err += x[i]*x[i+1]^j * cos(k*x[i+2])
    end
    return err 
end

# The sum or the squared error in each unknown 
function objective(x::SizedVector{n, T, Vector{T}})
    sum_err = zero(T)
    for iM = 1:m
        sum_err += moment_error(x, iM)^2
    end
    return sum_err
end

# Convert to barycentric coordinates
function area(x)
    nsum = n₀ + n₁ + n₂
    w = zeros(T, nsum) 
    α = zeros(T, nsum) 
    β = zeros(T, nsum) 
    γ = zeros(T, nsum) 
    icount = 1
    if !(n₀ === 0)
        w[icount] = x[1]
        α[icount] = T(1//3)
        β[icount] = T(1//3) 
        γ[icount] = T(1//3) 
        icount += 1 
    end
    for i = n₀ + 1 : 2 : n₀ + 2n₁ 
        w[icount] = x[i]/3
        α[icount] = (1 - 2x[i+1])/3
        β[icount] = (1 - α[icount])/2
        γ[icount] = β[icount]
        icount += 1 
    end
    for i = n₀ + 2n₁ + 1: 3 : n 
        r = x[i+1]
        a = x[i+2]
        w[icount] = x[i]/6
        α[icount] = (1 - 2r*cos(a))/3
        β[icount] = (1 + r*cos(a) - sqrt(T(3))*r*sin(a))/3
        γ[icount] = 1 - α[icount] - β[icount]
        icount += 1
    end
    return [ (w[i], α[i], β[i], γ[i]) for i ∈ 1:nsum ]
end

# Integration error function from Appendix II
function poly(wαβγ)
    exact = 2*T(factorial(big(p)))/T(factorial(big(p+2)))
    sum = zero(T)
    if n₀ !== 0
        w, α, β, γ = wαβγ[1]
        sum += w*α^p
    end
    for i = n₀ + 1:n₀ + n₁
        w, α, β, γ = wαβγ[i]
        sum += w*(α^p + 2*β^p)
    end
    for i = n₀ + n₁ + 1: n₀ + n₁ + n₂
        w, α, β, γ = wαβγ[i]
        sum += w*2*(α^p + β^p + γ^p)
    end 
    approx = sum
    err = (exact - approx)/approx
    return err
end

initial_guess = αβw_to_initial_guess() 
println("Polynomial degree: $p")
println("nᵢ = $n₀, $n₁, $n₂")    
@time res = optimize(objective, 
                     initial_guess, 
                     Optim.Options(g_tol=1e-200,
                                   iterations=Int64(1e6)
                                  )
                    )
x = Optim.minimizer(res)
if !Optim.converged(res)
    println(res)
end
wαβγ = area(x)
for t in wαβγ
    println(Float64.(t))
end
println("w, α, β, γ errors")
for i = 1:length(wαβγ)
    α_ref,β_ref,w_ref = αβw_Float64[i]
    γ_ref = 1 - α_ref - β_ref
    w, α, β, γ = wαβγ[i]
    w_err = Float64(w)-2w_ref 
    α_err = Float64(α)-α_ref
    β_err = Float64(β)-β_ref
    γ_err = Float64(γ)-γ_ref
    errs = (w_err, α_err, β_err, γ_err)
    for err in errs
        if abs(err) < 1e-14
            print("OK ")
        else
            print(err, " ")
        end
    end
    println()
end
println("Integration error")
println(poly(wαβγ))

weights = T[]
points = NTuple{2, T}[]
if n₀ !== 0
    push!(weights, wαβγ[1][1]/2)
    push!(points, (wαβγ[1][2], wαβγ[1][3]))
end
for i = n₀ + 1:n₀ + n₁
    w, α, β, γ = wαβγ[i]
    for j = 1:3
        push!(weights, w/2)
    end
    push!(points, (β, β))
    push!(points, (β, α))
    push!(points, (α, β))
end
for i = n₀ + n₁ + 1: n₀ + n₁ + n₂
    w, α, β, γ = wαβγ[i]
    for j = 1:6
        push!(weights, w/2)
    end
    push!(points, (γ, β))
    push!(points, (β, α))
    push!(points, (α, γ))
    push!(points, (γ, α))
    push!(points, (β, γ))
    push!(points, (α, β))
end

io = open("legendre_RefTriangle.jl", "a")
println(io, "@generated function gauss_quadrature(form::Val{:legendre},")
println(io, "                                     shape::RefTriangle,")
println(io, "                                     degree::Val{$p},")
println(io, "                                     type::Type{T}) where {T}")
println(io, """    weights = [:(\$(big"$(weights[1])")),""")
for i = 2:ng
println(io, """               :(\$(big"$(weights[i])")),""")
end
println(io, "                        ]")
println(io, """    points  = [:(\$(Point{2,T}(big"$(points[1][1])", big"$(points[1][2])"))),""")
for i in 2:ng
println(io, """               :(\$(Point{2,T}(big"$(points[i][1])", big"$(points[i][2])"))),""")
end
println(io, "                       ]")
println(io, "    return weights, points")
println(io, "end")
